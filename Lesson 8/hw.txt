1.1 Определить сложность следующих алгоритмов:
- Поиск элемента массива с известным индексом - O(1) для любого n получить значение по ключу 1 раз.

- Дублирование одномерного массива через foreach - O(n) - перебор массива из n пройдет за n итераций

- Рекурсивная функция нахождения факториала числа - O(n)
0: f(0) -> 1, 1:  1*f(0) -> 1,  2: 2*f(1) ->2, 3: 3*f(2)->3 n: n*f(n-1) -> n итераций

- Удаление элемента массива с известным индексом 0(1) Если по hash а не смещением в иной структуре данных.

3. Определить сложность следующих алгоритмов. Сколько произойдет итераций?
1)
```
$n = 100;
$array[]= [];

for ($i = 0; $i < $n; $i++) {  // O(n)
for ($j = 1; $j < $n; $j *= 2) {  O(log n)
$array[$i][$j]= true;
} }
Сложность: O(n*log n)

2)

$n = 100;
$array[] = [];

for ($i = 0; $i < $n; $i += 2) { O(n/2) => O(n)
for ($j = $i; $j < $n; $j++) { O(n)
$array[$i][$j]= true;
} }
```
Сложность: O(n^2)


Примеры во вложенных файлах

1.2.Определить сложность следующих алгоритмов. Сколько произойдет итераций?
a)

$n = 10000;
$array[]= [];

for ($i = 0; $i < $n; $i++) { // O(n)
  for ($j = 1; $j < $n; $j *= 2) { //O(log(n))
     $array[$i][$j]= true;
} }
Сложность: O(n*log(n))


b)

$n = 10000; //
$array[] = [];

for ($i = 0; $i < $n; $i += 2) { // O(n/2) => O(n)
  for ($j = $i; $j < $n; $j++) { //O(n)
   $array[$i][$j]= true;
} }
Сложность: O(n^2)

c)

$n = 10000;
$array[] = [];
foo($n);

function foo($n)
{
    while ($n > 0) {  //O(n)
        for ($j =0; $j < $n; $j++) { //O(n)
            $n--;
            foo($n); //рекурсия  O(n*n)
        }
    }
}
Сложность: O(n!)

